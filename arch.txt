═══════════════════════════════════════════════════════════════════════════════
                    LAYER 4 TCP LOAD BALANCER ARCHITECTURE
═══════════════════════════════════════════════════════════════════════════════

┌─────────────┐         ┌──────────────────┐         ┌─────────────────────┐
│   Client    │         │  Load Balancer   │         │   Backend Pool      │
│ (Browser/   │         │   (Port 8080)    │         │  (Ports 8000-12999) │
│  curl/app)  │         │                  │         │                     │
└─────────────┘         └──────────────────┘         └─────────────────────┘
      │                         │                              │
      │                         │                              │
      │                    ┌────▼────┐                         │
      │                    │ kqueue  │                         │
      │                    │ Event   │                         │
      │                    │ Loop    │                         │
      │                    └────┬────┘                         │
      │                         │                              │

═══════════════════════════════════════════════════════════════════════════════
PHASE 1: INITIALIZATION (main.cpp startup)
═══════════════════════════════════════════════════════════════════════════════

1. Create BackendPool
   ├─ Add 5000 IPv4 backends (127.0.0.1:8000-12999)
   ├─ Add 5000 IPv6 backends (::1:13000-17999)
   └─ Initialize atomic counter (currInd = 0)

2. Create Load Balancer Listening Socket
   ├─ int listen_fd = socket(AF_INET, SOCK_STREAM, 0)
   ├─ bind(listen_fd, "0.0.0.0:8080")
   ├─ listen(listen_fd, 128)  // backlog queue
   └─ Set non-blocking: fcntl(listen_fd, F_SETFL, O_NONBLOCK)

3. Initialize kqueue
   ├─ int kq = kqueue()
   ├─ Register listen_fd for READ events
   │   struct kevent ev;
   │   EV_SET(&ev, listen_fd, EVFILT_READ, EV_ADD, 0, 0, NULL)
   │   kevent(kq, &ev, 1, NULL, 0, NULL)
   └─ Enter event loop

═══════════════════════════════════════════════════════════════════════════════
PHASE 2: CLIENT CONNECTION (Step-by-step flow)
═══════════════════════════════════════════════════════════════════════════════

Client                  Load Balancer                    Backend
  │                           │                              │
  │──(1) TCP SYN─────────────>│                              │
  │   [Connect to :8080]      │                              │
  │                           │                              │
  │<─(2) TCP SYN-ACK──────────│                              │
  │                           │                              │
  │──(3) TCP ACK─────────────>│                              │
  │                     ┌─────▼─────┐                        │
  │                     │ kqueue    │                        │
  │                     │ detects   │                        │
  │                     │ EVFILT_   │                        │
  │                     │ READ on   │                        │
  │                     │ listen_fd │                        │
  │                     └─────┬─────┘                        │
  │                           │                              │
  │                     ┌─────▼─────────────────┐            │
  │                     │ int client_fd =       │            │
  │                     │ accept(listen_fd,...) │            │
  │                     │                       │            │
  │                     │ client_fd = 4         │            │
  │                     └─────┬─────────────────┘            │
  │                           │                              │
  │                     ┌─────▼──────────────────┐           │
  │                     │ Backend* b =           │           │
  │                     │ pool.RoundRobin()      │           │
  │                     │                        │           │
  │                     │ Returns: 127.0.0.1:8000│           │
  │                     └─────┬──────────────────┘           │
  │                           │                              │
  │                           │──(4) TCP SYN────────────────>│
  │                           │   [Connect to :8000]         │
  │                           │                              │
  │                           │<─(5) TCP SYN-ACK─────────────│
  │                           │                              │
  │                           │──(6) TCP ACK────────────────>│
  │                     ┌─────▼─────────────────┐            │
  │                     │ int backend_fd =      │            │
  │                     │ socket(...)           │            │
  │                     │ connect(backend_fd,   │            │
  │                     │   &b->address,...)    │            │
  │                     │                       │            │
  │                     │ backend_fd = 5        │            │
  │                     └─────┬─────────────────┘            │
  │                           │                              │
  │                     ┌─────▼──────────────────────────┐   │
  │                     │ Register BOTH sockets with kq: │   │
  │                     │                                │   │
  │                     │ EV_SET(&ev[0], client_fd,      │   │
  │                     │   EVFILT_READ, EV_ADD,...)     │   │
  │                     │ EV_SET(&ev[1], backend_fd,     │   │
  │                     │   EVFILT_READ, EV_ADD,...)     │   │
  │                     │                                │   │
  │                     │ kevent(kq, ev, 2, NULL, 0,..)  │   │
  │                     └─────┬──────────────────────────┘   │
  │                           │                              │
  │                     ┌─────▼──────────────────────────┐   │
  │                     │ Store mapping:                 │   │
  │                     │ map[client_fd] = backend_fd    │   │
  │                     │ map[backend_fd] = client_fd    │   │
  │                     └────────────────────────────────┘   │
  │                                                          │

═══════════════════════════════════════════════════════════════════════════════
PHASE 3: DATA FORWARDING (Bidirectional proxy)
═══════════════════════════════════════════════════════════════════════════════

Client                  Load Balancer                    Backend
  │                           │                              │
  │──(7) HTTP Request────────>│                              │
  │   "GET / HTTP/1.1"        │                              │
  │                     ┌─────▼─────────────────┐            │
  │                     │ kqueue fires:         │            │
  │                     │ EVFILT_READ on fd=4   │            │
  │                     │ (client_fd)           │            │
  │                     └─────┬─────────────────┘            │
  │                           │                              │
  │                     ┌─────▼──────────────────────────┐   │
  │                     │ char buf[8192];                │   │
  │                     │ ssize_t n = read(client_fd,    │   │
  │                     │                  buf, 8192);   │   │
  │                     │                                │   │
  │                     │ n = 18 bytes                   │   │
  │                     └─────┬──────────────────────────┘   │
  │                           │                              │
  │                     ┌─────▼──────────────────────────┐   │
  │                     │ int peer = map[client_fd];     │   │
  │                     │ // peer = backend_fd (5)       │   │
  │                     │                                │   │
  │                     │ write(backend_fd, buf, n);     │   │
  │                     └─────┬──────────────────────────┘   │
  │                           │                              │
  │                           │──(8) Forward Request────────>│
  │                           │   "GET / HTTP/1.1"           │
  │                           │                              │
  │                           │                        ┌─────▼─────┐
  │                           │                        │ Backend   │
  │                           │                        │ processes │
  │                           │                        │ request   │
  │                           │                        └─────┬─────┘
  │                           │                              │
  │                           │<─(9) HTTP Response───────────│
  │                           │   "HTTP/1.1 200 OK..."       │
  │                     ┌─────▼─────────────────┐            │
  │                     │ kqueue fires:         │            │
  │                     │ EVFILT_READ on fd=5   │            │
  │                     │ (backend_fd)          │            │
  │                     └─────┬─────────────────┘            │
  │                           │                              │
  │                     ┌─────▼──────────────────────────┐   │
  │                     │ ssize_t n = read(backend_fd,   │   │
  │                     │                  buf, 8192);   │   │
  │                     │                                │   │
  │                     │ int peer = map[backend_fd];    │   │
  │                     │ // peer = client_fd (4)        │   │
  │                     │                                │   │
  │                     │ write(client_fd, buf, n);      │   │
  │                     └─────┬──────────────────────────┘   │
  │                           │                              │
  │<─(10) Forward Response────│                              │
  │   "HTTP/1.1 200 OK..."    │                              │
  │                           │                              │

═══════════════════════════════════════════════════════════════════════════════
PHASE 4: CONNECTION CLEANUP
═══════════════════════════════════════════════════════════════════════════════

Client                  Load Balancer                    Backend
  │                           │                              │
  │──(11) TCP FIN────────────>│                              │
  │                     ┌─────▼─────────────────┐            │
  │                     │ kqueue fires:         │            │
  │                     │ EVFILT_READ on fd=4   │            │
  │                     │ read() returns 0      │            │
  │                     │ (EOF detected)        │            │
  │                     └─────┬─────────────────┘            │
  │                           │                              │
  │                     ┌─────▼──────────────────────────┐   │
  │                     │ int peer = map[client_fd];     │   │
  │                     │                                │   │
  │                     │ close(client_fd);   // fd=4    │   │
  │                     │ close(backend_fd);  // fd=5    │   │
  │                     │                                │   │
  │                     │ map.erase(client_fd);          │   │
  │                     │ map.erase(backend_fd);         │   │
  │                     └─────┬──────────────────────────┘   │
  │                           │                              │
  │                           │──(12) TCP FIN───────────────>│
  │                           │                              │

═══════════════════════════════════════════════════════════════════════════════
DATA STRUCTURES NEEDED
═══════════════════════════════════════════════════════════════════════════════

1. BackendPool (DONE ✓)
   - vector<Backend> servers
   - atomic<size_t> currInd
   - shared_mutex serversMutex

2. Connection Mapping (NEEDED)
   unordered_map<int, int> fdPairs;
   // fdPairs[client_fd] = backend_fd
   // fdPairs[backend_fd] = client_fd

3. kqueue Event Array (NEEDED)
   struct kevent events[MAX_EVENTS];  // Usually 64-1024

4. File Descriptor Sets (NEEDED)
   set<int> client_fds;    // Track all client connections
   set<int> backend_fds;   // Track all backend connections

═══════════════════════════════════════════════════════════════════════════════
ERROR HANDLING CASES
═══════════════════════════════════════════════════════════════════════════════

1. Backend Connection Fails
   ├─ connect() returns -1
   ├─ Mark backend unhealthy: backend->isHealthy = false
   ├─ Try next backend: pool.RoundRobin()
   └─ Send 502 Bad Gateway to client if all backends fail

2. Backend Becomes Unresponsive
   ├─ Set read timeout on backend_fd
   ├─ If timeout expires, close both connections
   └─ Decrement backend health score

3. Client Disconnects Mid-Request
   ├─ EVFILT_READ fires with read() = 0
   ├─ Close client_fd
   ├─ Close corresponding backend_fd
   └─ Remove from maps

4. Buffer Full (EAGAIN/EWOULDBLOCK)
   ├─ Register EVFILT_WRITE for destination fd
   ├─ Wait for writable event
   └─ Resume writing

═══════════════════════════════════════════════════════════════════════════════
PERFORMANCE CONSIDERATIONS
═══════════════════════════════════════════════════════════════════════════════

1. Use non-blocking I/O everywhere
   fcntl(fd, F_SETFL, O_NONBLOCK)

2. Set TCP_NODELAY on sockets
   int flag = 1;
   setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag))

3. Use SO_REUSEADDR on listening socket
   int reuse = 1;
   setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse))

4. Increase file descriptor limit
   ulimit -n 100000

5. Buffer size tuning
   char buf[8192];  // Start here, can increase to 64KB

═══════════════════════════════════════════════════════════════════════════════
TESTING CHECKLIST
═══════════════════════════════════════════════════════════════════════════════

[ ] Start 3 backend servers: nc -l 8000, nc -l 8001, nc -l 8002
[ ] Start load balancer: ./build/LoadBalancer
[ ] Test single request: curl localhost:8080
[ ] Test concurrent: ab -n 1000 -c 100 localhost:8080/
[ ] Test backend failure: kill backend mid-request
[ ] Test health recovery: restart backend, verify it receives traffic
[ ] Monitor with: netstat -an | grep 8080

═══════════════════════════════════════════════════════════════════════════════